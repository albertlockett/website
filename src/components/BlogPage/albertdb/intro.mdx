import Code from '../../Code'
import PngWritePath1 from './write_path_1.png'
import PngWriteFlush from './write_flush_fixed.png'

# albertdb

Welcome to albertdb, a key-value database.
Its design is inspired by other LSM databses like Scylla, Dynamo and RocksDB.
I wrote this as a a side-project while teaching myself Rust and also to
  demonstrate some competance in database development.

You might enjoy reading this article if you are interested in learning more
  about database internals.

[The code for albertdb can be found on my github](https://github.com/albertlockett/albertdb)

There are code snippets used in the article for demonstration purposes.

_This article, like albertdb, is work-in-progress (WIP)_

## Engine

This section will describe the read and write paths of the database.

It will reference many of the data structures that have been used to build
  this database but not in great detail.
This section is mostly focused on how the pieces fit together at a high level.
The individual components will be described in better detail in other sections.

### Write Path

The database receives key-value records to be written consisting of arbitrary
  arrays of bytes.
<Code language="rust">
{`pub fn write(&mut self, key: &[u8], value: &[u8]) {`}
</Code>

The record is then written to an in-memory balanced tree called a _memtable_ and
  it is also peristed in an on-disk file called the write ahead log (_WAL_).
<Code language="rust">
{`    self.writable_wal.write(key, Some(value)).unwrap();
    self.writable_table // <-- memtable
        .insert(key.to_vec(), Some(value.to_vec()));`}
</Code>

The WAL will be used to recover the memtable in case of a database crash.

<img src={PngWritePath1} />

#### Memtable Flush

The memtable cannot grow indefinity, otherwise it would use up all the
  memory on the system.
When the memtable reaches a certain threshold, it is flushed to an on-disk
  data structure called an _sstable_.

<Code language="rust">
{`    if self.writable_table.size() > self.config.memtable_max_count {
        self.flush_writable_memtable();
    }`}
</Code>

Once the memtable begins being flushed, new values are no-longer written to it.
A new memtable is created and it becomes the writable memtable.
The flushing memtables remain avaiable in memory for the read path while
  the flush is in progress.

Once the flush is complete, the sstable becomes available for the read path.
The flushing memtable is no-longer needed and it is dropped from memory.
The WAL is also no-longer needed and it is also deleted.

<img src={PngWriteFlush} />

### Read Path

Reads will check each data structure that could contain the data in order of
  how recently the data was written.
This ensures we always read the freshest value.

First, the current writable memtable is checked.
If the data is not found, each flushing memtable is checked until until the data
  is found.
If the value cannot be found in any of the memtables,
  the sstables will be checked next in order of how recently they were created.

_TODO there's a bug in this algorithm that an older memtable could finish flushing
after the a newer one?_

_TODO add a picture of the readpath_
_TODO add a picture of the code going through these checks_

### Deletes

_TODO write about how the tombstones work_


## Memtables

Memtables are an in-memory balanced tree that are used to buffer writes before
  they are flushed to disk as immutable sstables.

There are many kinds of balanced binary trees that could be used for this.
B-Trees would have been more traditional, and a Red-Black Tree or 2-3 tree could
  also have worked but albertdb uses a treap with randomization to ensure
  balancing.
This implementation was chosen for it's simplicity (a simple data structure was
  needed as I was just a beginner at rust when I started this).

Treaps are binary trees that are balanced in the left-right direction 
  (like a binary search tree) using one measure and in the up-down direction 
  (like a heap) using another. _Tree + Heap = treap_
In this case, our databases keys are used to balance the tree left to right,
  and a random number is used to balance the tree in the up-down direction.

Using a random variable ensures that the tree will be balanced on average.
This can be shown mathemetically that the maximum expected value of the depth of
  any node in the tree proportional to the logarithm of the number of the number
  of nodes
The details are a bit gory but we can also think about it intuitively.
As more and more nodes are added,
  if we are randomly choosing at which depth to insert the nodes, 
  then eventually it becomes less likely we'll keep adding to the top
  or the bottom.
I don't intend for this to be a post about randomized treaps.
An excellent reference to learn more is _Advanced Algorithms and Data Structures_
  by Marcello La Rocca.




