import Code from '../../Code'
import FullFlow from './full_flow.png'

# _Sign in with terrylockett.ca_

## A Hands-on Approach to Understanding OAuth 2.0 PKCE Flow

Many web developers use some form of OAuth to authenticate users of their site,
  although some may not even know it.
The implementation details are often abstracted away,
  behind the APIs and SDKs of some Saas auth provider like Okta or Auth0.
Through this abstraction thorough understanding of what OAuth is and how it works is usually
  not necessary in an engineer's daily work.
For some, years of productive web development can take place with a blissful understanding that 
  OAuth does not need to be understood.
And why bother - isn't auth something best left to the _real_ professionals?

Maybe you're curious and want to learn more.
  Maybe you're interfacing with some 3rd party that does not have such a simple SDK, 
  or maybe you even need to roll your own implementation.

Informative aritcles abound the unitiated who want/need to learn more about OAuth,
  but many of these articles describe OAuth in the abstract or at a relatively high level.
They sometimes lack information that could be used to glean an understanding of how the 
  system that executes the flow is actually built.

Some software engineers are more comfortable reasoning about systems from the bottom-up.
To this cohort, the implementation defines the architecture, not the other way around.
Their creedo: "_just show me the code_". This post attempts to do that.

I'll be describing an example implementation of this OAuth 2 PKCE authorization flow.
If you're a software engineer who has struggled to understand how this flow works in your SPA,
  I hope that this post is useful to you.

This article assumes no prior knowlege of OAuth.
Many articles describing PKCE, the modern way that single page web applications (SPAs) use OAuth,
  often assume a prior knowlege of the older, less secure Implicit Grant flow,
  but not this one.
That said, an basical understanding of web development and HTTP would be helpful.

The full code for this solution can be found at https://github.com/albertlockett/terry-sso

## The Use-Case (or _a gift to my brother_)

There's one important thing that all popular big tech companies have:
the "login with ..." button.
Google, Facbook, Github, Twitter, etc.
Navigate your web browser to to some podunk internet startup's app page, 
  and often they'll let you register and authenticate from with the identity from some real, respectable, tech company.

On the topic of respectable tech companies... 
  https://terrylockett.ca is a website founded by my brother in 2011. 
At the time of this writing, it has just celebrated it's 10th birthday of being on the internet!
The site offers its visitors a cornicopia of content & features,
  including a W3C certification, a picture of a cat, two gifs of snoop dogg, 
  and a variety of flash based videos.

In an effort to keep up with the big dogs, https://terrylockett.ca will now also support
  provide authentication solution for 3rd party sites.
The "login with terrylockett.ca" button will soon be all over the internet.
More importantly, the engineering team behind this feature is going to show you exactly how it's done.
Strap yourself in and prepare to have your mind blown out of your skull.

## Background

Web developers who put the the "login with terrylocket.ca" on their site effectively want to delegate
  the responsibility to terrylockett.ca of confirming the user is who they say they is.
Making this determination is called _authentication_.
terrylockett.ca has a great, functional, login page that follows all the best security practices.
In order delegate authentication, the user on some website somehow need to navigate to terrylockett.ca, login,
  and then have the results of that login returned to the original site.

_OAuth_ is the term the industry uses for this kind of workflow.
Sometimes people will use the term "OAuth 2" or "OAuth 2.0" when discussing this flow,
  to specify that they not talking about OAuth version 1,
  which is less secure and fell out of favor about around 2013.

### The Simplified Flow

A simplified OAuth flow goes like this:
- 1 - The browser starts the flow by sending a request to a 3rd party site that will handle the authentication
  As part of this request, it will tell the 3rd party where to send the results in the form of a callback URL
- 2 - The requests ends up with the user being on the 3rd party app's login screen. 
  The user enters their credentials and clicks login. 
  On a successful login, the browser gets redirected back with a _token_

The flow is called the _Implicit Grant_ flow and for a long time it was the only option.

```
TODO - put a pic here of this happening
```

### Tokens

The end-goal of the OAuth flow is to receive the token.


Note - the JWT format will be explained more detail in a later section.
For now it's more than enough to know that commonly these tokens to take the form of a signed 
  _JWT token_ (aka a _JSON Web Token_).
It's basically base64 encoded json with a special signature that can be used to verify the token's authenticity.

The token can be used by your application to  determine who the user is (i.e. the user's _identity_).
There's often extra information included with the token about what the user is allowed to do
  and what APIs they are allowed to use (i.e. their _access_).
Since the token serves this dual purpose, 
  it is often customary for this final stage of the flow to actually return two different tokens:
  an _access token_ and an _id token).

```
TODO section here about scopes, etc?
```

```
TODO section here about openID connect
```

### The Problem with Implicit Grant

What could go wrong with the authorization flow we described above?
The main security issue is that there are ways that token can be intercepted. 
The way Implicit Grant is generally implemented,
  after user sucessfully authenticates the authentication server sends an HTTP 302 response with
  to the callback URL, including the token in the url
```
302 
Location=https://example.com?token=<token>
```
This will cause the browser will then make an HTTP GET request as it navigates to that location.
In this scenario, its possible the token will be stored in the browser history or that an 
  attacker could intercept the token from the URL during the GET request.

Of course it would be more secure if the browser could somehow request the token ater being redirected
  after the login using some kind of asynchronous request.
Why don't we do this in implicit grant flow?
The whole reason the token was supplied in the URL as part of this flow is because, at the time
  it was designed, CORS was not widely supported.
e.g., the mechanism did not exist at the time.
Luckily in modern times the limitation does not exist.
CORS is now widely supported and we're free to make asynchronous requests to the authorization server
  to our hearts' content (or until we get repsonse code 429).

```
TODO add a section here about front channels and back channels
```

### PKCE - Securing the Token Exchange

What if implicit grant was enhanced to send back a special _code_ on the front channel 
  (in the redirect URL) that could be exchanged for a token on the back channel 
  (in an aysnchronous post request).
Would that work?

It could help a bit, but it doesnt fully solve the problem.
That code could be intercepted just as easily as the token in implicit grant.

If only there was some special secret that the client knew a head of time that it could send with the code on the back channel.
The authorization server could then verify that that the secret is correct and associated with the code.
E.g. the client could send the verification secret to prove that it is one who is really allowed to exchange the code for the token.

We're describing here is something called the _Authorization Grant_ flow.
The problem with this flow in the context of a single page web app is that the browser needs to know the secret somehow.
If we embed the secret in the javascript or HTML of the web page
  the secret is effectively public!
Anyone with the ability to inspect the site's static asets could steal it and then it would
  provide no protection of the code/token exchange.
But what if there wasn't one static secret?
We could generate the secret dynamically in our JavaScript code...

The trick here is that the authorization server would need to be able to check that the client supplied the
  correct secret as part of the code exchange.
To do this we could supply the hash of the secret to the authorization server ahead of time.
To verify the secret which is supplied during the exchange, 
  we hash it and then compare it to the hash previously supplied.
```
TODO add a link to learn more about hashing?
```

What we're now describing is an extension to the Authorization Grant flow called Proof Key Code Exchange (or PKCE or "pixy").
In PKCE parlance, the secret is called a _verifier_ and the hash of that secret is called the _challenge_.
```
TODO add a picture?
```

In this flow, when the user makes the original request to the authorization server,
  in order to begin the authorization flow,
  it supplies all the reular parameters (audience, scope, callback url) _and the challenge_.
The flow then proceeds exactly like an authorization grant flow:
  user logs in and then gets redirected back to the callback url with the code.
The browser then sends the request to exchang the code _and the verifier_ for the token.

## Implementation

With all that background out of the way,
  here's the real flow in all it's gory detail.

If you skipped ahead to this part of the article because you saw a pretty picture,
  feel free to just start reading here if you'd like. 
You can refer to the front-matter as reference.
The rest of this article is going to show the code that implements the flow in the
  diagram below.

<img src={FullFlow} />

I've broken the flow into three phases.

There's basically three API calls that will be made as part of the flow,
  we'll start by setting up our endpoints:

<Code language="rust">
{`#[actix_web::main]
async fn main() -> std::io::Result<()> {
  let server = HttpServer::new(|| {
    let cors = Cors::permissive();
    App::new()
      .wrap(cors)
      .route("/oauth2/authorize", web::get().to(redir_to_login))
      .route("/oauth2/login", web::post().to(handle_login))
      .route("/oauth2/token", web::post().to(handle_token))
  });
   
  server.bind("127.0.0.1:4000")
    .expect("error binding server")
    .run()
    .await
}
`}
</Code>


## Phase one

This is the phase where we begin the login flow.
In this phase we
- create a _verifier_
- create a _challenge_ from the verifier
- begin a login session with the API
- redirect the browser to the login screen

The very first step of the flow is to create the _verifier_.
Recal that the function of the verifier (along with the code), will be exchanged for a token in Phase Three.
Its form is _a cryptographically random value_,
  which sounds spooky,
  but it's effectively a bunch of random bytes.

The from the verifier, we generate the _challenge_.
The challenge_type (is that what it's called?) can take two different forms, None or S256 (TODO confirm this).
If the challenge type is S256, the challenge is the base64, encoding of the SHA256 hash of the verifier
  (for challenge type none, it's just the base64 encoding).

The _verifier_ and _challenge_ are both generated on the client.
Here's what the code to do this could look like.
In the getChallenge method,
  we're hashing the verifier before we encode it which means we're using the S256 challenge type.
It uses the fancy new browser _crypto_ api.

<Code language="typescript">
{`export class Verifier {
  constructor() {
    this.array = new Uint8Array(64);
    window.crypto.getRandomValues(this.array);
    this.getChallenge = this.getChallenge.bind(this);
  }
  
  async getChallenge(): string {
    return toBase64(await sha256(this.array));
  }
  
  toString() {
    return toBase64(this.array);
  }
}
  
async function sha256(bytes: Uint8Array): Uint8Array {
  const hash = await crypto.subtle.digest('SHA-256', bytes);
  return new Uint8Array(hash);
}
  
function toBase64(bytes: Uint8Array): string {
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}
`}
</Code>

Once we have a verifier and challenge,
  we gotta get prepared to do some stuff.
We'll need to store the verifier for use in phase three, so that will go into a cookie.

Then we'll send the challenge down to the API server.
When we do that, we'll get redirected to the login page for the beginning of phase two.

There's a few other things we might want to send to the API Server when we do this.
Recall that after phase two,
  we'll get redirected back to the original application before doing phase three.
But, we won't be re-visiting the original application in the interim,
  which means that if the app knows where step two should return to,
  it's gotta send that info along.
All this to say, we gotta send the callback URL.

There's other funky stuff you could send as well to possibly control the token we eventually receive.
Maybe when you implement this flow for your website,
  you want the token you eventually recieve to have certain scopes,
  or maybe an audience claim.
Recall that the scopes could be used to determine what a user is really allowed to do.
The audience claim could be used determine which APIs the user has access to.

All the parameters we send (challenge, callback_url, scopes and audience),
  will be stored in a special session object.
We'll redirect the user to the login screen with a reference to the unique identifier
  of the session.

<Code language="rust">
{`#[derive(Debug, Deserialize)]
pub struct AuthorizeParams {
    challenge: String,
    callback_url: String,
    audience: String,
    scopes: String,
}
  
async fn redir_to_login(req: HttpRequest) -> HttpResponse {
    let params = web::Query::<AuthorizeParams>::from_query(req.query_string()).unwrap();
    let session_id = Uuid::new_v4().to_string();
    dao::store_session(
        &session_id,
        dao::Session {
            challenge: params.challenge.clone(),
            callback_url: params.callback_url.clone(),
            audience: params.audience.clone(),
            scopes: params.scopes.clone(),
        },
    )
    .await;
    let redirect_location = format!("http://localhost:1234?session_id={}", session_id,);
    HttpResponse::Found()
        .header("Location", redirect_location)
        .finish()
}`}
</Code>

Thhe code to start this flow from the browser looks like this:

<Code language="typescript">
{`type LoginParams = {
  callbackUrl: string;
  audience?: string;
  scopes?: string[];
};
  
export async function doLogin(params: LoginParams) {
  // store the verifier in the cookie for later use.
  // It expires in 5 minutes, hopefully it doesn't take that long for users to type their password etc.
  const verifier = new Verifier();
  document.cookie = \`terry_auth=\${verifier}; new Date(new Date().getTime() + 300_000); path=/\`;
  
  const challenge = await verifier.getChallenge();
  let queryString = \`challenge=\${challenge}&callback_url=\${params.callbackUrl}\`;
  queryString += \`&audience=\${params.audience ?? ''}\`;
  queryString += \`&scopes=\${params.scopes?.join(',') ?? ''}\`;
  window.location = \`http://localhost:4000/oauth2/authorize?\${queryString}\`;
}
`}
</Code>

If we publish the code to call work through thi flow as an SDK,
  here's how some developer might use the SDK on their site to begin the login flow.

<Code language="javascript">
{`import * as sdk from 'terry-spa-sdk';
  
const button = document.getElementById('login');
button.addEventListener(
  'click',
  function () {
    sdk.doLogin({
      callbackUrl: ` + "`${window.location.origin}/callback`" + `
    });
  },
  false
);
`}
</Code>

## Phase Two:

In the previous step, the user began the login flow by creating some login state 
  and then had their browser redirected to the login page of terrylockett.ca
For our implementation, we'll use a simple html form to accept the user's username
  and password.
In reality these applications could be quite a bit more interesting.
Features on such an application could include MFA or 
  not having the user re-authenticate if they already
  have an active session with the autentication provider.

We're going to keep it simple.
A Simple web form for username and password will do.

Here's the front-end of our login application.
<Code language="typescript">
{`
import React from 'react';
import ReactDOM from 'react-dom';
  
import './styles.scss';
  
function App() {
  const params = new URLSearchParams(window.location.search);
  const sessionId = params.get('sessionId');
  const error = params.get('error')
  return (
    <div className="login-page">
      <h1>Login</h1>
      <form method="post" action="http://localhost:4000/oauth2/login">
        <label>username</label>
        <input type="text" name="username" />
        <br />
        <label>password</label>
        <input type="password" name="password" />
        <br />
        <input type="hidden" name="session_id" value={sessionId} />
        <button>OK</button>
        <br />
        <Error error={error} />
      </form>
    </div>
  );
}
  
ReactDOM.render(<App />, document.getElementById('app'));
`}
</Code>

Recall that in the previous phase we sent several parameters to the authentication server
  describing what kind of token the user wishes to receive
  and where they wish to be redirected back to after a successful login.
When the user submits the form,
  we'll need to somehow retrieve those parameters.
Hence, we also submit the _session_id, which is just some id that can be used to
  retrive the other parameters later on.
This concept of a session ID is more of an implementation detail than anything else,
  i.e, it's not necessaily part of the Oauth spec.

There's also an error component here which will handle the error states described below.

Finally, no respectable web developer would put his site on the internet without some _style_:
<Code language="css">
{`
body {
  margin: 0;
  top: 0;
  background: lightblue;
}
`}
</Code>

Here's the code the handles the response when the user clicks _OK_ to submit their credentials.
The purpose of this handler is to eventually generare a code that can be exchanged for a token
  and then send a response that will redircet the browser back to the callback url.
But that only happens if the request was successful. 

Before we can do that, we need to perform some checks:
- check if the session ID is valid (not some garbage input)
- check that the username and password are correct (aka _authenticate_ the user)
- check that this user is allowed to create the type of token they are attempting to create

The third check is really an application specific detail,
  but I added it here to show where this kind of business logic could be built into 
  an Oauth flow implementation.
For example, maybe in the original request the user requested a scope of `deleteAllRepositories`
  with an audience of `my-source-control-system.example.com`.
Probably only admin users are allowed to do something like this, so in this case we'd deny the
  request.

In each case, we'll also want to handle the failed check differently.

If the user sends an invalid session ID,
  we'll have ot keep them on the login screen but send them a message that something
  invalid has happened.
There's no other option - we couldn't redirect them back to the original app
  because the callback url a session attribute and the session we can't find.
To do this, we'll 302 the user to the login page and add the querystring parameter
  `?error=invalid_session`

Similarly, if the user enters invalid credentials,
  we'll keep them on the login screen
In this case however we want to show a different error -
  namely that the credentials they entered were not correct.

When we do authenticate the user, now we can check that they're allowed to be issued
  the token they have asked for when they initiated the session.
In this case, it was the original application that made the request to initiate the
  session, so we'll want to let that application know that what they sent was invalid.
This means, we'll 302 back to the original application via the callback url, 
  and we'll also return an error code in the query string.
  `?error=not_allowed_scopes` or `?error=not_allowed_audience`

Finally, if we haven't hit any of our edge cases we'll create a new code,
  store the some state that associates the code, the user and the session,
  and return the code to the original application by adding it to the query string
  in the redirect to the callback url.

<Code language="rust">
{`
#[derive(Debug, Deserialize)]
pub struct PasswordFormValues {
    username: String,
    password: String,
    session_id: String,
}
  
async fn handle_login(params: web::Form::<PasswordFormValues>) -> HttpResponse {
     // check if the session is valid
    let session_op = dao::get_session(&params.session_id).await;
    if session_op.is_none() {
        let location = format!(
            "http://localhost:1234?session_id={}&error={}",
            params.session_id, "invalid_session"
        );
        return HttpResponse::Found().header("Location", location).finish();
    }
    let session = session_op.unwrap();
  
    // check if the password is valid ...
    if !is_valid_password(&params).await {
        let location = format!(
            "http://localhost:1234?session_id={}&error={}",
            params.session_id, "invalid_credentials"
        );
        return HttpResponse::Found().header("Location", location).finish();
    }
  
    // check that the user has requested allowed scopes
    let allowed_scopes = dao::get_allowed_scopes(&params.username);
    let mut not_allowed_scope_requested = false;
    session.scopes.split(",")
        .for_each(|scope| {
            not_allowed_scope_requested |= !allowed_scopes.contains(&scope.to_string());
        });
    if not_allowed_scope_requested {
        let callback_url = format!("{}?error=not_allowed_scopes", session.callback_url.clone());
        return HttpResponse::Found()
            .header("Location", callback_url)
            .finish();
    }
  
    // check that the audience is allowed
    let audience_restrictions = dao::get_audience_restrictions(&params.username);
    if audience_restrictions.is_some() && !audience_restrictions.unwrap().contains(&session.audience) {
        let callback_url = format!("{}?error=not_allowed_audience", session.callback_url.clone());
        return HttpResponse::Found()
            .header("Location", callback_url)
            .finish();
    }
  
    // store the code and redirect user w/ code
    let code = format!("{}", Uuid::new_v4());
    dao::store_code(&code, &params.username, &params.session_id).await;
    let callback_url = format!("{}?code={}", session.callback_url.clone(), code);
    HttpResponse::Found()
        .header("Location", callback_url)
        .finish()
}
   
/// check that the user supplied valid credentials
/// don't do like this irl - it's not a very smart way to check creds
async fn is_valid_password(params: &web::Form::<PasswordFormValues>) -> bool {
  let valid_credentials: bool;
  let password = dao::get_password(&params.username).await;
  println!("{:?}", password);
   
  if matches!(password, None) {
    valid_credentials = false; // no user found
  } else {
    valid_credentials = params.password == password.unwrap();
  }
  return valid_credentials;
}
`}
</Code>

Here's how our first two error messages are handled in the browser.
<Code language="typescript">
{`
import React from 'react';
  
type ErrorProps = {
  error: string;
};
  
const errorMessages = {
  invalid_credentials: 'Your password and/or username is wrong!!!!!!',
  invalid_session: 'Invalid session state!!!!!!!!!!!'
};
  
export default function Error(props: ErrorProps) {
  if (!props.error) {
    return null;
  }
  
  return (
    <div className="error">
      <b>Error happen:</b>
      <br />
      <em>{errorMessages[props.error]}</em>
    </div>
  );
}
`}
</Code>

We'll be handling the other error states later on.

## Phase Three

In the third phase of our oauth flow, we have been redirected to the callback url and 
  we are ready to exchange the code for the token.
From the client's perspective,
  this is a relatively simple procedure.
We just send the code to the server, along with the verifier we created during phase one.
Recall, the verifier was stored in a cookie!

<Code language="typescript">
{`
type ExchangeCodeParams = {
  code: string;
};
  
type ExchangeCodeResponse = {
  access_token: string;
  id_token: string;
};
  
export async function exchangeCode(
  params: ExchangeCodeParams
): ExchangeCodeResponse {
  const verifier = getVerifierFromCookie(document.cookie);
  const response = await fetch('http://localhost:4000/oauth2/token', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ code: params.code, verifier })
  });
  const result = await response.json();
  return result;
}
  
function getVerifierFromCookie(cookie): string {
  const verifier = cookie
    .split(';')
    .map((s) => s.trim())
    .find((c) => c.startsWith('terry_auth'))
    .replace('terry_auth=', '');
  return verifier;
}
`}
</Code>

Then we invoke this function on our callback page:
<Code language="typescript">
{`
import * as sdk from 'terry-spa-sdk';
  
let token = '';
  
(async function () {
  if (!window.location.pathname.startsWith('/callback')) {
    return;
  }
  
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');
  const error = params.get('error');
  if (error) {
    handleError(error);
  } else {
    const result = await sdk.exchangeCode({ code });
    token = result.access_token;
  }
})();
  
async function handleError(error) {
  console.error(error);
  document.addEventListener('DOMContentLoaded', function () {
    const errorContainer = document.getElementById('error');
    errorContainer.innerText = 'An error occurred';
  });
}
`}
</Code>


## Bibliography / Further Reading
- [_PKCE: What and Why?_ ](https://dropbox.tech/developers/pkce--what-and-why-#:~:text=%E2%80%9CPKCE%20(RFC%207636)%20is,to%20access%20their%20Dropbox%20data.)
- [OAuth.net Impllicit Grant Page](https://oauth.net/2/grant-types/implicit/)
  including a great [youtube video](https://www.youtube.com/watch?v=CHzERullHe8) about why you should prefer PKCE
- [The original Oauth2 spec for PKCE](https://oauth.net/2/pkce/)
- [OpenID Connect Guide](https://auth0.com/docs/authenticate/protocols/openid-connect-protocol)
- [OpenID Connect Scopes](https://openid.net/specs/openid-connect-basic-1_0.html#Scopes)