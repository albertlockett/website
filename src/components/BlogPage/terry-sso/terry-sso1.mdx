import Code from '../../Code'

# Login

There's one important thing that all popular big tech companies have:
the "login with _X_" button.
Google, Facbook, Github, Twitter.. the list goes on.
Navigate your web browser to to some podunk internet startup's app page, 
  and 9 times out of 10 they'll let you register and authenticate from 
  with the identity from some real, respectable, tech company.

On the topic of respectable, https://terrylockett.ca is a website founded in 2011. 
At the time of this writing, it has just celebrated it's 10th birthday of being on the internet.
The site offers it's visitors a cornicopia of content & features,
  including a W3C certification, a picture of a cat, two gifs of snoop dogg, 
  and a variety of flash based videos.

In an effort to stay modern and cool, https://terrylockett.ca will now also support
  provide authentication solution for 3rd party sites.
The "login with terrylockett.ca" button will soon be all over the internet.
More importantly, the engineering team is going to show you exactly how it's done.

Hold onto your butts and prepare to have your minds blown out of your skull.

## Background

There's basically three API calls that will be made as part of the flow,
  we'll start by setting up our endpoints:

<Code language="rust">
{`#[actix_web::main]
async fn main() -> std::io::Result<()> {
  let server = HttpServer::new(|| {
    let cors = Cors::permissive();
    App::new()
      .wrap(cors)
      .route("/oauth2/authorize", web::get().to(redir_to_login))
      .route("/oauth2/login", web::post().to(handle_login))
      .route("/oauth2/token", web::post().to(handle_token))
  });
   
  server.bind("127.0.0.1:4000")
    .expect("error binding server")
    .run()
    .await
}
`}
</Code>


## Phase one

This is the phase where we begin the login flow.
In this phase we
- create a verifier
- create a challenge from the verifier
- begin a login session with the API
- redirect the browser to the login screen

The very first step of the flow is to create the _verifier_.
Recal that the function of the verifier (along with the code), will be exchanged for a token in Phase Three.
Its form is _a cryptographically random value_,
  which sounds spooky,
  but it's effectively a bunch of random bytes.

The from the verifier, we generate the _challenge_.
The challenge_type (is that what it's called?) can take two different forms, None or S256 (TODO confirm this).
If the challenge type is S256, the challenge is the base64, encoding of the SHA256 hash of the verifier
  (for challenge type none, it's just the base64 encoding).

The _verifier_ and _challenge_ are both generated on the client.
Here's what the code to do this could look like.
In the getChallenge method,
  we're hashing the verifier before we encode it which means we're using the S256 challenge type.
It uses the fancy new browser _crypto_ api.

<Code language="typescript">
{`export class Verifier {
  constructor() {
    this.array = new Uint8Array(64);
    window.crypto.getRandomValues(this.array);
    this.getChallenge = this.getChallenge.bind(this);
  }
  
  async getChallenge(): string {
    return toBase64(await sha256(this.array));
  }
  
  toString() {
    return toBase64(this.array);
  }
}
  
async function sha256(bytes: Uint8Array): Uint8Array {
  const hash = await crypto.subtle.digest('SHA-256', bytes);
  return new Uint8Array(hash);
}
  
function toBase64(bytes: Uint8Array): string {
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}
`}
</Code>

Once we have a verifier and challenge,
  we gotta get prepared to do some stuff.
We'll need to store the verifier for use in phase three, so that will go into a cookie.


Then we'll send the challenge down to the API server.
When we do that, we'll get redirected to the login page for the beginning of phase two.

There's a few other things we might want to send to the API Server when we do this.
Recall that after phase two,
  we'll get redirected back to the original application before doing phase three.
But, we won't be re-visiting the original application in the interim,
  which means that if the app knows where step two should return to,
  it's gotta send that info along.
All this to say, we gotta send the callback URL.

There's other funky stuff you could send as well to possibly control the token we eventually receive.
Maybe when you implement this flow for your website,
  you want the token you eventually recieve to have certain scopes,
  or maybe an audience claim.
I'm going to omit all that for now,
  but this would be the place to send them along.

Anyway, the code to start this flow from the browser looks like this:

<Code language="typescript">
{`type LoginParams = {
  callbackUrl: string;
};
  
export async function doLogin(params: LoginParams) {
  // store the verifier in the cookie for later use.
  // It expires in 5 minutes, hopefully it doesn't take that long for users to type their password etc.
  const verifier = new Verifier();
  document.cookie = \`terry_auth=\${verifier}; \${new Date(new Date().getTime() + 300_000)}; path=/\`;
  
  const challenge = await verifier.getChallenge();
  window.location = \`http://localhost:4000/oauth2/authorize?challenge=\${challenge}&callback_url=\${params.callbackUrl}\`; 
}
`}
</Code>